

local GuiLibrary = shared.GuiLibrary

local players = game:GetService("Players")

local RunService = game:GetService("RunService")

local Client = require(game:GetService("ReplicatedStorage").TS.remotes).default.Client

local textservice = game:GetService("TextService")

local repstorage = game:GetService("ReplicatedStorage")

local lplr = players.LocalPlayer

local lighting = game:GetService("Lighting")

local connectionstodisconnect = {}

local WhitelistFunctions = shared.vapewhitelist

local targetinfo = shared.VapeTargetInfo

local collectionservice = game:GetService("CollectionService")

local uis = game:GetService("UserInputService")

local mouse = lplr:GetMouse()

local bedwars = {}

local bedwarsblocks = {}

local blockraycast = RaycastParams.new()

blockraycast.FilterType = Enum.RaycastFilterType.Whitelist

local getfunctions

local oldchar

local oldcloneroot

local bettergetfocus = function()

	if KRNL_LOADED then 
		return ((game:GetService("Players").LocalPlayer.PlayerGui.Chat.Frame.ChatBarParentFrame.Frame.BoxFrame.Frame.ChatBar:IsFocused() or searchbar:IsFocused()) and true or nil) 

	else

		return game:GetService("UserInputService"):GetFocusedTextBox()

	end

end

local betterisfile = function(file)

	local suc, res = pcall(function() return readfile(file) end)

	return suc and res ~= nil

end

local requestfunc = syn and syn.request or http and http.request or http_request or fluxus and fluxus.request or request or function(tab)

	if tab.Method == "GET" then

		return {

			Body = game:HttpGet(tab.Url, true),

			Headers = {},

			StatusCode = 200

		}

	else

		return {

			Body = "bad exploit",

			Headers = {},

			StatusCode = 404

		}

	end

end 

local matchState = 0

local kit = ""

local antivoidypos = 0

local kills = 0

local beds = 0

local lagbacks = 0

local otherlagbacks = 0

local matchstatetick = 0

local lagbackevent = Instance.new("BindableEvent")

local requestfunc = syn and syn.request or http and http.request or http_request or fluxus and fluxus.request or request or function(tab)

	if tab.Method == "GET" then

		return {

			Body = game:HttpGet(tab.Url, true),

			Headers = {},

			StatusCode = 200

		}

	else

		return {

			Body = "bad exploit",

			Headers = {},

			StatusCode = 404

		}

	end

end 

local queueteleport = syn and syn.queue_on_teleport or queue_on_teleport or fluxus and fluxus.queue_on_teleport or function() end

local teleportfunc

local getasset = getsynasset or getcustomasset or function(location) return "rbxasset://"..location end

local storedshahashes = {}

local oldshoot

local blocktable

local inventories = {}

local currentinventory = {

	["inventory"] = {

		["items"] = {},

		["armor"] = {},

		["hand"] = nil

	}

}

function IsAlive(plr)

    plr = plr or lplr

    if not plr.Character then return false end

    if not plr.Character:FindFirstChild("Head") then return false end

    if not plr.Character:FindFirstChild("Humanoid") then return false end

    if plr.Character:FindFirstChild("Humanoid").Health < 0.11 then return false end

    return true

end

function GetMatchState()

	return bedwars["ClientHandlerStore"]:getState().Game.matchState

end

local queueType = "bedwars_test"

local networkownertick = tick()

local uninjectflag = false

local vec3 = Vector3.new

local cfnew = CFrame.new

local clients = {

	ChatStrings1 = {

		["KVOP25KYFPPP4"] = "vape",

		["IO12GP56P4LGR"] = "future",

		["RQYBPTYNURYZC"] = "rektsky"

	},

	ChatStrings2 = {

		["vape"] = "KVOP25KYFPPP4",

		["future"] = "IO12GP56P4LGR",

		["rektsky"] = "RQYBPTYNURYZC"

	},

	ClientUsers = {}

}

local function GetURL(scripturl)

	if shared.VapeDeveloper then

		return readfile("vape/"..scripturl)

	else

		return game:HttpGet("https://raw.githubusercontent.com/7GrandDadPGN/VapeV4ForRoblox/main/"..scripturl, true)

	end

end

local entity = shared.vapeentity





checkpublicrepo = function(id)

	local suc, req = pcall(function() return requestfunc({

		Url = "https://raw.githubusercontent.com/7GrandDadPGN/VapeV4ForRoblox/main/CustomModules/6872274481.lua",

		Method = "GET"

	}) end)

	if not suc then

		checkpublicreponum = checkpublicreponum + 1

		spawn(function()

			local textlabel = Instance.new("TextLabel")

			textlabel.Size = UDim2.new(1, 0, 0, 36)

			textlabel.Text = "Loading CustomModule Failed!, Attempts : "..checkpublicreponum

			textlabel.BackgroundTransparency = 1

			textlabel.TextStrokeTransparency = 0

			textlabel.TextSize = 30

			textlabel.Font = Enum.Font.SourceSans

			textlabel.TextColor3 = Color3.new(1, 1, 1)

			textlabel.Position = UDim2.new(0, 0, 0, -36)

			textlabel.Parent = GuiLibrary["MainGui"]

			task.wait(2)

			textlabel:Remove()

		end)

		task.wait(2)

		return checkpublicrepo(id)

	end

	if req.StatusCode == 200 then

		return req.Body

	end

	return nil

end

local publicrepo = checkpublicrepo(game.PlaceId)

if publicrepo then

    loadstring(publicrepo)()

end







local RunLoops = {RenderStepTable = {}, StepTable = {}, HeartTable = {}}

do

	function RunLoops:BindToRenderStep(name, num, func)

		if RunLoops.RenderStepTable[name] == nil then

			RunLoops.RenderStepTable[name] = game:GetService("RunService").RenderStepped:Connect(func)

		end

	end



	function RunLoops:UnbindFromRenderStep(name)

		if RunLoops.RenderStepTable[name] then

			RunLoops.RenderStepTable[name]:Disconnect()

			RunLoops.RenderStepTable[name] = nil

		end

	end



	function RunLoops:BindToStepped(name, num, func)

		if RunLoops.StepTable[name] == nil then

			RunLoops.StepTable[name] = game:GetService("RunService").Stepped:Connect(func)

		end

	end



	function RunLoops:UnbindFromStepped(name)

		if RunLoops.StepTable[name] then

			RunLoops.StepTable[name]:Disconnect()

			RunLoops.StepTable[name] = nil

		end

	end



	function RunLoops:BindToHeartbeat(name, num, func)

		if RunLoops.HeartTable[name] == nil then

			RunLoops.HeartTable[name] = game:GetService("RunService").Heartbeat:Connect(func)

		end

	end



	function RunLoops:UnbindFromHeartbeat(name)

		if RunLoops.HeartTable[name] then

			RunLoops.HeartTable[name]:Disconnect()

			RunLoops.HeartTable[name] = nil

		end

	end

end



local function runcode(func)

	func()

end



local funnyFly = {["Enabled"] = false}

local funnyAura = {["Enabled"] = false}



runcode(function()

	local funnyFly 

	local part

	local cam = workspace.CurrentCamera

    funnyFly = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({

        ["Name"] = "FunnyFly",

        ["Function"] = function(callback)

            if callback then

                if funnyAura.Enabled then funnyAura.ToggleButton(false) end

                

                local origy = entity.character.HumanoidRootPart.Position.y

                part = Instance.new("Part", workspace)

                part.Size = Vector3.new(1,1,1)

                part.Transparency = 1

                part.Anchored = true

                part.CanCollide = false

                cam.CameraSubject = part

                lplr.HumanoidRootPart.Anchored = true

                RunLoops:BindToHeartbeat("FunnyFlyPart", 1, function()

                    local pos = entity.character.HumanoidRootPart.Position

                    part.Position = Vector3.new(pos.x, origy, pos.z)

                end)

                local cf = entity.character.HumanoidRootPart.CFrame

                entity.character.HumanoidRootPart.CFrame = CFrame.new(cf.x, 300000, cf.z)

                if entity.character.HumanoidRootPart.Position.X < 50000 then 

                    entity.character.HumanoidRootPart.CFrame *= CFrame.new(0, 100000, 0)

                end

            else

                RunLoops:UnbindFromHeartbeat("FunnyFlyPart")

                lplr.HumanoidRootPart.Anchored = false

                local pos = entity.character.HumanoidRootPart.Position

                local rcparams = RaycastParams.new()

                rcparams.FilterType = Enum.RaycastFilterType.Whitelist

                rcparams.FilterDescendantsInstances = {workspace.Map}

                rc = workspace:Raycast(Vector3.new(pos.x, 300, pos.z), Vector3.new(0,-1000,0), rcparams)

                if rc and rc.Position then

                    entity.character.HumanoidRootPart.CFrame = CFrame.new(rc.Position) * CFrame.new(0,3,0)

                end

                cam.CameraSubject = lplr.Character

                part:Destroy()

                RunLoops:BindToHeartbeat("FunnyFlyVeloEnd", 1, function()

                    entity.character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)

                    entity.character.HumanoidRootPart.CFrame = CFrame.new(rc.Position) * CFrame.new(0,3,0)

                end)

                task.wait(1)

                RunLoops:UnbindFromHeartbeat("FunnyFlyVeloEnd")

                

            end

        end

    })

end)

runcode(function()

	local AcValue = {["Value"] = 7.5}

	local ACBypass = {["Enabled"] = false}

	ACBypass = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({

		["Name"] = "AnticheatBypass",

		["Function"] = function(callback)

			if callback then

local lplr = game.Players.LocalPlayer

local cam = workspace.CurrentCamera

local oldchar

local clone



oldchar = lplr.Character

oldchar.Archivable = true

clone = oldchar:Clone()

oldchar.PrimaryPart.Anchored = false



local humc = oldchar.Humanoid:Clone()

humc.Parent = lplr.Character

game:GetService("RunService").Stepped:connect(function()

    local mag = (clone.PrimaryPart.Position - oldchar.PrimaryPart.Position).Magnitude

    if mag >= AcValue["Value"] then

        oldchar:SetPrimaryPartCFrame(clone.PrimaryPart.CFrame)

    end

end)

pcall(function()

    oldchar.PrimaryPart:GetPropertyChangedSignal("CFrame"):connect(function()

        (oldchar.PrimaryPart.CFrame - Vector3.new(0,1.85,0))

    end)

end)



cam.CameraSubject = clone.Humanoid 

clone.Parent = workspace

lplr.Character = clone

for _,v in pairs(lplr.Character:GetChildren()) do

    v.Transparency = 0.5

    if v:IsA("Hat") then

        v:Destroy()

    elseif v:IsA("Shirt") then

        v:Destroy()

    elseif v:IsA("Pants") then

        v:Destroy()

    end

end

else

	       CreateNotification("Never", "cant disable it.", 5)

			end

end

	})

AcValue = ACBypass.CreateSlider({

	["Name"] = "AC TP",

	["Min"] = 1,

	["Max"] = 9,

	["Function"] = function(val) end,

	["Default"] = 7.5

})

end)

runcode(function()

	local velo

	local flyup = false

	local flydown = false

	local connection

	local connection2

	local BounceFly = {["Enabled"] = false}

	BounceFly = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({

		["Name"] = "BounceFly",

		["Function"] = function(callback)

			if callback then

				velo = Instance.new("BodyVelocity")

				velo.MaxForce = Vector3.new(0,9e9,0)

				velo.Parent = lplr.Character:FindFirstChild("HumanoidRootPart")

				connection = uis.InputBegan:Connect(function(input)

					if input.KeyCode == Enum.KeyCode.Space then

						flyup = true

					end

					if input.KeyCode == Enum.KeyCode.LeftShift then

						flydown = true

					end

				end)

				connection2 = uis.InputEnded:Connect(function(input)

					if input.KeyCode == Enum.KeyCode.Space then

						flyup = false

					end

					if input.KeyCode == Enum.KeyCode.LeftShift then

						flydown = false

					end

				end)

				spawn(function()

					repeat

						task.wait()

						for i = 1,15 do

							task.wait()

							if not BounceFly["Enabled"] then return end

							velo.Velocity = Vector3.new(0,i*1.25+(flyup and 42 or 0)+(flydown and -42 or 0),0)

						end

						for i = 1,15 do

							task.wait()

							if not BounceFly["Enabled"] then return end

							velo.Velocity = Vector3.new(0,-i*1+(flyup and 42 or 0)+(flydown and -42 or 0),0)

						end

					until not BounceFly["Enabled"]

				end)

			else

				velo:Destroy()

				connection:Disconnect()

				connection2:Disconnect()

				flyup = false

				flydown = false

			end

		end

	})

end)

--[[

runcode(function()

    function GetBeds()

        local beds = {}

        for i,v in pairs(game:GetService("Workspace"):GetChildren()) do

            if string.lower(v.Name) == "bed" and v:FindFirstChild("Covers") ~= nil and v:FindFirstChild("Covers").BrickColor ~= lplr.Team.TeamColor then

                table.insert(beds,v)

            end

        end

        return beds

    end

    function GetPlayers()

        local players = {}

        for i,v in pairs(game:GetService("Players"):GetPlayers()) do

            if v.Team ~= lplr.Team and IsAlive(v) then

                table.insert(players,v)

            end

        end

        return players

    end

    local AutoWinz = false

    local AutoWin = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({

        ["Name"] = "AutoWin",

        ["Callback"] = function(callback)

        	AutoWinz = callback

            if AutoWinz then

                spawn(function()

                    if GetMatchState() ~= 1 then

                        repeat task.wait() until GetMatchState() == 1 or not AutoWinz

                        if not AutoWinz then return end

                    end

                    local start = tick()

                    local beds = GetBeds()

                    for i,v in pairs(beds) do

                        repeat

                            task.wait(0.01)

                            if lplr:GetAttribute("DenyBlockBreak") == true then

                                lplr:SetAttribute("DenyBlockBreak",nil)

                            end

                            lplr.Character:FindFirstChild("HumanoidRootPart").CFrame = v.CFrame + Vector3.new(0,3,0)

                            local x = math.round(v.Position.X/3)

                            local y = math.round(v.Position.Y/3)

                            local z = math.round(v.Position.Z/3)

                            game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.DamageBlock:InvokeServer({

                                ["blockRef"] = {

                                    ["blockPosition"] = Vector3.new(x,y,z)

                                },

                                ["hitPosition"] = Vector3.new(x,y,z),

                                ["hitNormal"] = Vector3.new(x,y,z)

                            })

                        until not v:FindFirstChild("Covers") or not v or not AutoWinz

                        if not AutoWinz then return end

                    end

                    local players = GetPlayers()

                    for i,v in pairs(players) do

                        repeat

                            task.wait(0.01)

                            lplr.Character:FindFirstChild("HumanoidRootPart").CFrame = v.Character:FindFirstChild("HumanoidRootPart").CFrame + Vector3.new(0,3,0)

                        until not IsAlive(v)

                    end

                    CreateNotification("AutoWin","Took "..math.abs(start - tick()).." Seconds/Ticks to win Game",5)

                end)

            end

        end

    })

end)

--]]
